<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Apollo&#39;s blog</title>
    <link>https://Apollo2light.github.io/Apollo2light/</link>
    <description>Recent content on Apollo&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 26 Apr 2022 23:04:13 +0800</lastBuildDate>
    
	<atom:link href="https://Apollo2light.github.io/Apollo2light/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>10.nodejs基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/10.nodejs%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 23:04:13 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/10.nodejs%E5%9F%BA%E7%A1%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.webpack基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/9.webpack%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 23:00:35 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/9.webpack%E5%9F%BA%E7%A1%80/</guid>
      <description>(一) webpack安装使用 1.简介  webpack是个打包工具，它默认处理js文件，同时也能借助loaders实现对其他类型文件的处理，同时还能用插件来简化我们的开发流程。
 2.配置环境 先要安装一下准备环境，node，因为webpcak是基于node的打包工具 其次要安装webpack和webpack-cli
npm init -y npm install webpack webpack-cli -D 3.命令行打包 安装好了以后，我们可以通过命令行直接来进行打包，可以先新建一个index.js文件，然后在命令行:
npx webpack index.js 打包完成后会有一个默认的打包文件，我们要想看看效果可以新建一个index.html来引入默认的打包文件，然后看效果。
4.脚本打包 在此之前，我们先来修改一下目录，让结构更加清晰，我们新建一个src目录，将index.js放在里面，然后新建一个dist目录，将index.html放在里面
4.1 配置webpack.config.js 接着在根目录下新建一个webpack.config.js的文件，然后在里面配置一些打包的参数，
const path = require(&amp;#39;path&amp;#39;); module.exports = { entry:{ &amp;#39;main&amp;#39;:&amp;#39;./src/index.js&amp;#39; }, output:{ filename:&amp;#39;bundle.js&amp;#39;, path:path.resolve(__dirname,&amp;#39;dist&amp;#39;) } } 4.2 配置package.json 配置好了以后，我们再来配置一下package.json文件，实现脚本打包的功能，
{ &amp;#34;scripts&amp;#34;: { &amp;#34;bundle&amp;#34;: &amp;#34;webpack&amp;#34; }, } 此时在命令行中直接使用 npm run bundle，等待打包成功后，手动打开我们的index.html文件看看效果，至此我们已经完成了webpack的安装和使用。
（二）webpack打包资源(loader)  前面我们安装并使用了webpack，我们处理的内容是js文件，那它如何处理其他类型的文件呢？比如说图片，css，字体等等，这就需要用到loaders，也就是说，webpack能认得js文件，但他不认识其他文件，所以需要一个中间人来告诉他该怎么处理. ###1.处理图片资源 首先先来看一下图片文件。首先我们先来截屏一张图片，然后把它放在src/dog.png，然后要把它挂载在index.html上，在index.js中这样来写；
 import dog from &amp;#39;./dog.png&amp;#39;; var img = new Image(); img.</description>
    </item>
    
    <item>
      <title>8.ts基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/8.ts%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 23:00:24 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/8.ts%E5%9F%BA%E7%A1%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/7.%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 23:00:10 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/7.%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</guid>
      <description>1.简介 1.每个用户针对每个公众号会产生一个安全的OpenID 2.一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID 3.在申请到认证公众号之前，申请一个接口测试号，立即开始接口测试开发 4.每个接口都有每日接口调用频次限制 5.公众平台以access_token为接口调用凭据，它在2小时内有效，1天内获取次数有限 6.公众平台接口调用仅支持80端口 7.公众号主要通过公众号消息会话 公众号内网页来为用户提供服务 8.公众号消息会话：公众号是以微信用户的一个联系人形式存在的，消息会话是公众号与用户交互的基础 9.消息服务的类型：群发消息，被动回复消息(加解密)，客服消息，模板消息 10.公众号内网页：获取用户的基本信息，微信JS-SDK EncodingAESKey: ZroCcwPJ2wVUemo94iPc8DJHiEXi3lHcJ3aXKDwUI2r 2.步骤 1.申请自己服务器，搭建web服务，申请公众号，在微信公众号平台的设置与开发-基本配置添加url(开发者ip)，token(验证开发者)和EncodingAESKey(消息加密密钥) 2.在微信公众号平台填好开发者信息后点击提交，微信服务器会向开发者服务器发送signature，timestamp，nonce，开发者用token, timestamp, nonce组合加密生成hashcode，对比微信发来的signature和自己生成的hashcode是否一致，如果一致返回echostr到微信服务器 3.用户发送消息到公众号，微信服务器将消息包装成xml格式发往开发者服务器，开发者服务器解析后发回内容到微信服务器，微信服务器解析后发给用户 微信文档：https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Getting_Started_Guide.html
centos防火墙：https://blog.csdn.net/s_p_j/article/details/80979450 https://blog.csdn.net/Linda_Lindaaaa/article/details/88836146</description>
    </item>
    
    <item>
      <title>4.jquery基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/4.jquery%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:58:40 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/4.jquery%E5%9F%BA%E7%A1%80/</guid>
      <description>1.匿名函数自执行 jquery2.0.3中，源码首先是一个自执行的匿名函数, 匿名函数就是没有函数名的函数，目的是为了保护变量不被污染,如下：
(function(window,undefined){ //具体源码  })(window); 要理解它需要先来了解js的函数命名：
js函数有2种命名方式：声明式和函数表达式
 声明式：function demo(){ //会被解释器优先编译 } 函数表达式： let demo = function(){ //解释器逐行解释 }  声明式：不论在哪里调用demo都能正常输出a，因为在开始执行前声明的函数都被提升了
demo(); function demo(){ console.log(&amp;#39;a&amp;#39;) } 函数表达式：必须要在表达式后才能调用demo，因为解释器是逐行执行
demo(); let demo = function(){ console.log(&amp;#39;a&amp;#39;) } 比对一下就可知：
(function(){ }) () | | demo () 那为什么不写成：function(){ }()呢？答案是语法里并不支持这么做，最简的方式就是加小括号
(function(){ })() 2.封装好的功能暴露到全局 采用匿名函数自执行可以很好的保护变量不受污染，但也需要把写好的功能暴露出去提供使用,我们平常使用时：
$()或者jQuery() 在jquery2.0.3中，它是将其挂载到了window全局对象来实现的
(function(window,undefined){ if ( typeof window === &amp;#34;object&amp;#34; &amp;amp;&amp;amp; typeof window.document === &amp;#34;object&amp;#34; ) { window.jQuery = window.$ = jQuery; } })(window); 3.</description>
    </item>
    
    <item>
      <title>6.react基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/6.react%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:58:13 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/6.react%E5%9F%BA%E7%A1%80/</guid>
      <description>1.概念  单页面应用：加载单个HTML页面和所需资源，与页面的任何交互，页面都不会重新加载 jsx：js的扩展集，每个 JSX 元素只是调用 React.createElement的语法糖 组件：分为函数组件和类组件，区别是类组件上添加了许多别的特性 钩子函数：生命周期函数，在特定时间自动触发的函数 Props：jsx传值与子组件的节点组成的对象，props 是只读的 State：组件内部的数据，只能通过setState({ })更改 react非受控组件：用非react处理数据方式处理的组件 状态提升：不同层级子组件传值 组合继承：组件通过组合堆砌而不是继承实现,实质相当于槽的概念 context：复杂组件传值 错误边界：避免出错导致应用崩溃 Ref转发：组件外选中特定的dom refdom：组件内选中特定的dom 高阶组件：传入组件输出组件，实现对组件的加强，比如redux的connect Portals：组件可以脱离父组件层级挂载在DOM树的任何位置 Profiler：任意位置的性能测试 协调： diff算法 webcomponent：w3c支持的组件化标准  2.react细节 1.组件 // 1.获取容器 const domContainer = document.getElementById(&amp;#39;root&amp;#39;); // 2.创建虚拟dom //类组件 class Hello extends React.Component { constructor(props){ super(props); this.state = {name: &amp;#39;hello,world!&amp;#39;}; } componentWillMount(){ // 不能直接修改state  // this.state = { name:&amp;#39;hello&amp;#39;};  // this.setState({ name:&amp;#39;你好&amp;#39;})  } render() { return (&amp;lt;div&amp;gt;{this.state.name}&amp;lt;/div&amp;gt;) } }; //函数组件 function World(props){ console.</description>
    </item>
    
    <item>
      <title>5.vue基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/5.vue%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:57:27 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/5.vue%E5%9F%BA%E7%A1%80/</guid>
      <description>0.数据监测和代理 //数据代理：通过vm操作_data中的属性 //vue内部: vm._data = data Object.defineProperty(vm,&amp;#39;a&amp;#39;,{ get(){ return vm._data.a } }) let vm = new Vue({ //等价于vm.$mount(&amp;#39;#root&amp;#39;)  el:&amp;#39;#root&amp;#39;, //函数式必须返回对象  data(){ return{ a:1 } } }) let data = { name:&amp;#39;a&amp;#39;, address:&amp;#39;b&amp;#39; } const obs = new Observer(data); console.log(obs); let vm = {} vm._data = data = obs; function Observer(obj){ const keys = Object.keys(obj); keys.forEach((k) =&amp;gt; { Object.defineProperty(this,k,{ get(){ return obj[k]; }, set(val){ console.log(`${k}被改了,需要解析模版，生成虚拟dom，渲染页面`) obj[k] = val; } }) }) } 添加响应式对象：vm.</description>
    </item>
    
    <item>
      <title>3.js基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/3.js%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:48:33 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/3.js%E5%9F%BA%E7%A1%80/</guid>
      <description>0.前提 javascript包括三部分：
 1.ECMA：基础语法 2.DOM: 操作文档节点 3.BOM：操作浏览器节点 str方法：https://www.runoob.com/js/js-obj-string.html arr方法：https://www.runoob.com/jsref/jsref-obj-array.html reg方法：https://www.runoob.com/jsref/jsref-obj-regexp.html  1.变量  值：复制新内存 引用：指向同一块内存的地址  let obj0 = { name:&amp;#34;deepcopy&amp;#34;, description:&amp;#34;copy all args from object except its own prop&amp;#34;, arr:[&amp;#34;refrence&amp;#34;,&amp;#34;data&amp;#34;] } let obj1 = { name:&amp;#34;deepcopy&amp;#34;, description:&amp;#34;copy all args from object except its own prop&amp;#34;, arr:[&amp;#34;refrence&amp;#34;,&amp;#34;data&amp;#34;], obje: obj0 } /** * 深拷贝 */ function deepCopy(obj){ //边界判断  if(typeof obj !=&amp;#34;object&amp;#34; || obj == null){ return obj; } //定义返回结果  let result; if(obj instanceof Array){ //待拷贝的对象是数组类型  result = [] }else{ //待拷贝的对象是object类型  result = {} } //开始拷贝  for (const key in obj) { //只拷贝obj自身的属性  if (obj.</description>
    </item>
    
    <item>
      <title>2.css基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/2.css%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:48:26 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/2.css%E5%9F%BA%E7%A1%80/</guid>
      <description>css资料  css属性：https://www.runoob.com/cssref/css-reference.html css选择器：https://www.runoob.com/cssref/css-selectors.html css动画：https://www.runoob.com/cssref/css-selectors.html css单位：https://www.runoob.com/cssref/css-units.html  flex布局：容器和子项目设置属性 /* 容器： */ display：flex； flex-direction：row/column/row-reverse justify-content：flex-*/center/space-* align-items：center flex-wrap：wrap align-content：center flex-flow：column wrap； /* 子项目： */ flex：1； align-self：flex-end order：-1 </description>
    </item>
    
    <item>
      <title>1.html基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/1.html%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:48:19 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/1.html%E5%9F%BA%E7%A1%80/</guid>
      <description>html资料  html标签：https://www.runoob.com/tags/ref-byfunc.html html5新标签：https://www.runoob.com/html/html5-new-element.html html属性：https://www.runoob.com/tags/ref-standardattributes.html html事件：https://www.runoob.com/tags/ref-eventattributes.html 音视频：https://www.runoob.com/tags/ref-av-dom.html canvas属性：https://www.runoob.com/tags/ref-canvas.html http状态码：https://www.runoob.com/tags/html-httpmessages.html  </description>
    </item>
    
    <item>
      <title>4.mac终端</title>
      <link>https://Apollo2light.github.io/Apollo2light/tools/4.mac%E7%BB%88%E7%AB%AF/</link>
      <pubDate>Tue, 26 Apr 2022 21:45:49 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/tools/4.mac%E7%BB%88%E7%AB%AF/</guid>
      <description>1.终端 0.iTerm2是默认终端的替代品，oh-my-zsh是为了简化zsh的配置的shell
1.查看所有shell
cat /etc/shells 2.默认shell
新版zsh默认zsh：echo $SHELL 更换默认shell：chsh -s /bin/zsh 3.配置文件
#所有命令失效： export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin - a. /etc/profile - b. /etc/paths - c. ~/.bash_profile - d. ~/.bash_login - e. ~/.profile - f. ~/.bashrc(启动终端自动加载) 2.配置环境变量 Mac的usr/bin目录是不允许增删文件的，可以通过向usr/local/bin增删文件来实现在终端里直接运行
#移动软件 sudo mv -f 文件名 /usr/local #添加变量 sudo vim /etc/profile # maven环境变 MAVEN_HOME=&amp;#34;/usr/local/apache-maven-3.8.4&amp;#34; export MAVEN_HOME export PATH=${PATH}:${MAVEN_HOME}/bin source /etc/profile 3.快捷键 1.截图：Command + Shift + 4 2.录屏：Command + Shift + 5 4.常用命令 改主机名: hostnamectl set-hostname npm换源: npm config set registry https://registry.</description>
    </item>
    
    <item>
      <title>3.hugo博客</title>
      <link>https://Apollo2light.github.io/Apollo2light/tools/3.hugo%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Tue, 26 Apr 2022 20:59:21 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/tools/3.hugo%E5%8D%9A%E5%AE%A2/</guid>
      <description>1.步骤  1.申请GitHub账号并配置ssh 2.brew安装hugo后选择主题 3.熟悉常见hugo指令 4.GitHub pages部署博客  2.指令 #安装hugo brew install hugo #新建站点 hugo new site xx #添加主题 cd xx git clone https://github.com/rmsubekti/the-roots-home.git themes/the-roots-home hugo server -t the-roots-home --buildDrafts #打包 hugo --theme=the-roots-home --baseUrl=&amp;#34;https://Apollo2light.github.io&amp;#34; --buildDrafts 3.写博客 #新建页面 cd apo_blog hugo new xx/xx.md #编写内容 code #打包 hugo --theme=the-roots-home --baseUrl=&amp;#34;https://Apollo2light.github.io/Apollo2light/&amp;#34; --buildDrafts #将打包好的public内容复制到apollo_blog #上传到apollo仓库 git add . git config --local user.name &amp;#39;Apollo2light&amp;#39; git config --local user.email &amp;#39;2141975795@qq.com&amp;#39; git commit -m &amp;#39;xxx&amp;#39; git push 4.</description>
    </item>
    
    <item>
      <title>1.git原理</title>
      <link>https://Apollo2light.github.io/Apollo2light/tools/1.git%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 26 Apr 2022 19:01:11 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/tools/1.git%E5%8E%9F%E7%90%86/</guid>
      <description>1.分布式版本控制系统 1.1 本质 git是分布式版本控制系统，它与集中式版本控制的本质区别是：
 分布式：客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录 集中式：客户端只提取最新版本的文件快照，不包括完整的历史记录  1.2 配置  /etc/gitconfig 文件：系统级别，git config –system对当前操作系统所有用户生效 ~/.gitconfig 文件：用户级别，git config –global 对当前操作系统该用户生效 .git/config 文件：当前文件级别，git config –local仅针对当前项目有效  git config —list #配置列表 git config --global user.name #用户名 git config --global user.email #用户邮箱 1.3 分区 对于任何一个文件，在 Git 内都只有三种状态：
 已提交（committed）：该文件已经被安全地保存在本地数据库中了 已修改（modified）：修改了某个文件 已暂存（staged）：已修改的文件放在下次提交时要保存的清单中  因此可以看到 Git 管理项目时，文件流转的三个区域：
 工作目录：编辑代码 暂存区域：完成编辑但未提交 本地仓库：.git目录，存放数据和修改信息  HEAD：指向当前所处分支 description：仅供 GitWeb 程序使用，无需关心 info/：全局性排除文件 config：配置文件 hooks/：客户端或服务端的钩子脚本 index：暂存区信息 objects/：所有存储的数据 refs/：存储指向数据（分支、远程仓库和标签等)的提交对象的指针    2.</description>
    </item>
    
    <item>
      <title>2.git配置多账号</title>
      <link>https://Apollo2light.github.io/Apollo2light/tools/2.git%E9%85%8D%E7%BD%AE%E5%A4%9A%E8%B4%A6%E5%8F%B7/</link>
      <pubDate>Tue, 26 Apr 2022 18:25:43 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/tools/2.git%E9%85%8D%E7%BD%AE%E5%A4%9A%E8%B4%A6%E5%8F%B7/</guid>
      <description>0.使用 使用的都是ssh协议
git clone git@Apollo2light.github.com:Apollo2light/Apollo2light.git 1.单客户端多账号 1.1 问题描述 单个客户端如何管理 多个账号在多个代码托管平台的代码拉取推送？
 a用户  github.come gitee.com   b用户  github.com gitee.com    1.2 解决方案  1.本地生成多个账号对应不同平台的ssh公私钥 2.将公钥部署到对应平台 3.本地拉取推送  1.2.1 生成公私钥 #进入公私钥配置地址 cd ~/.ssh/ #生成公私钥,ed25519为生成时使用的算法 ssh-keygen -t ed25519 -C &amp;#34;a@qq.com&amp;#34; ssh-keygen -t ed25519 -C &amp;#34;b@qq.com&amp;#34; #添加到ssh-agent，加快速度 eval &amp;#34;$(ssh-agent -s)&amp;#34; ssh-add -K ~/.ssh/id_a_ed25519 ssh-add -K ~/.ssh/id_b_ed25519 #配置访问时不同用户对应的私钥 vim config #======================== #github gaoyakang Host gaoyakang.github.com HostName github.com IdentityFile ~/.ssh/id_306_ed25519 user git #github apollo Host Apollo2light.</description>
    </item>
    
  </channel>
</rss>