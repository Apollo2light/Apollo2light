<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Apollo&#39;s blog</title>
    <link>https://Apollo2light.github.io/Apollo2light/</link>
    <description>Recent content on Apollo&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 May 2022 01:10:37 +0800</lastBuildDate>
    
	<atom:link href="https://Apollo2light.github.io/Apollo2light/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>0.java路线</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/0.java%E8%B7%AF%E7%BA%BF/</link>
      <pubDate>Thu, 12 May 2022 01:10:37 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/0.java%E8%B7%AF%E7%BA%BF/</guid>
      <description>1.java基础 java基础知识包括：
 基础语法：关键词/运算符/数据结构 + 流程 面向对象：三大特性/接口 应用程序：集合反射多线程/网络异常数据库/nio加类库 新特性：泛型注解和枚举/流式拆装lambda  2.javaWeb 3.ssm 4.springboot 5.springcloud </description>
    </item>
    
    <item>
      <title>5</title>
      <link>https://Apollo2light.github.io/Apollo2light/cs/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 12 May 2022 00:24:53 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/cs/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.计算机网络</title>
      <link>https://Apollo2light.github.io/Apollo2light/cs/4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Thu, 12 May 2022 00:24:35 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/cs/4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>计算机网络 1.疑惑 网络连接是怎么建立的，如何观察到它们？
2.四层模型 网络四层模型
 应用层：http 传输层：tcp报文/3握4挥 网络层：ip 链路层：线缆  3.应用层 计算机内人可识别的最小单元是字符 HTTP的请求报文由四部分组成：
 请求行(request line) 请求头部(header) 空行 请求数据(request data)  3.1 请求行 请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔
 请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT； URL 统一资源定位符，是一种资源位置的抽象唯一识别方法； HTTP协议版本，常用的有HTTP/1.0和HTTP/1.1  3.2 请求头部 它为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔
3.3 空行 请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据
3.4 请求数据 请求数据不在GET方法中使用，而在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最长使用的请求头部是Cntent-Type和Content-Length
4.传输层 传输层将应用层字节数据封装成报文，该报文包括：
 源端口SourcePort目的端口DestinationPort 序列号Sequence Number，它表示本报文段所发送数据的第一个字节的编号 确认号Acknowledgment Number，它表示接收方期望收到发送方下一个报文段的第一个字节数据的编号 首部长度Header Length，它表示数据段中的“数据”部分起始处距离 TCP 数据段起始处的字节偏移量 保留Reserved，它表示为 TCP 将来的发展预留空间 标志位：CWR/ECE/URG/ACK/PSH/PST/SYN/FIN 窗口大小Window Size，它表示从 Ack Number 开始还可以接收多少字节的数据量 校验位TCP Checksum，它用于确认传输的数据是否有损坏 紧急指针Urgent Pointer，它指出本数据段中为紧急数据的字节数 选项Option，长度不定，但长度必须是 32bits 的整数倍  5.网络层 网络层将报文数据封装成IP数据报格式传输 每个IP数据报包含两部分：</description>
    </item>
    
    <item>
      <title>3</title>
      <link>https://Apollo2light.github.io/Apollo2light/cs/3.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 12 May 2022 00:24:25 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/cs/3.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2</title>
      <link>https://Apollo2light.github.io/Apollo2light/cs/2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 12 May 2022 00:24:15 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/cs/2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>1.计组</title>
      <link>https://Apollo2light.github.io/Apollo2light/cs/1.%E8%AE%A1%E7%BB%84/</link>
      <pubDate>Thu, 12 May 2022 00:23:51 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/cs/1.%E8%AE%A1%E7%BB%84/</guid>
      <description>1.什么是电路？ 物质由原子组成，原子由电子核与核外电子组成，在电场力的作用下核外电子绕原子核做圆周运动，当施加外部电场力时，导体的核外电子脱离原子核的束缚沿着电场力的方向运动：
 电子的定向移动就形成了电流 原子核同时也会阻止核外电子的力形成了电阻 核外电子移动后造成正负电子间的势能差形成了电压 在宏观世界，电流，电阻和电压会被转化为其他形式的能量，为了描述这些能量，提出了焦耳定律 q=i^2rt,焦耳反应了电流的做功大小 p=ui,功率反应了做功快慢  2.什么是电子管？ 通电的灯丝处产生大量活跃的电子，在电子管中加入外加正电压的金属板，活跃的电子在电场力的作用下朝着金属板移动产生电流，改变外加电压的正负即可控制通断，在外加正电压金属板与活跃电子之间再加入金属板，可用于加强电场。这样通过电压的正负极转换就能控制电子管的通断，但电子管的体积大，功耗高，难以适应急剧增长的需求 
3.什么是晶体管？ 纯净的硅原子最外层有4个电子，它既不容易得到电子也不容易失去电子，被叫做本征半导体，
 在纯净的硅原子中加入带有5电子的磷原子，整体带负电，叫做N型半导体 在纯净的硅原子中加入带有3电子的硼原子，整体带正电，叫做P型半导体  晶体二极管：将N型半导体和P型半导体结合，前者电子浓度高，后者空穴浓度高，产生扩散运动，随之建立电场，电场力又会驱使电子产生漂移运动，扩散与漂移运动最终达到平衡，当外加电压与内电场方向一致时，漂移运动占据主导，电路导通，当外加电压与内电场方向相反时，扩散运动占据主导，电路中断，这样通过控制电场方向就可以来控制晶体管的通断
晶体三极管：将三个p型与n型的半导体组合，就会造出类似电子管的装置，
 发射极类似通电的灯丝处产生大量活跃的电子 集电极类似在电子管中加入外加正电压的金属板 基极类似在外加正电压金属板与活跃电子之间的增强金属板  以NPN型三极管为例，它包括基极，集电极和发射极，基极负责调控通断
 1.b处电流极小时be/bc都不导通，整体出电量几乎为0，处于截止状态 2.b处电流逐渐增大，be/bc慢慢导通，整体出电量慢慢增大，处于放大状态 3.b处电流增大到将bc完全导通时，be/bc全部导通，整体出电量保持最大不变，处于饱和状态  通过调节基极电压就可以控制 集电极 与 发射极 的通断
放大电路 基极上控制着集电极电流，集电极电阻处的电压就大致等于放大后的基极处电压，外接电容避免回路向发射极灌入电流同时接受信号输入
4.什么是数字电路？ 将模拟信号进行采样后数字化，用二进制的补码形式来表示这些数字化的信号，然后将这些信号通过以逻辑代数为原理，晶体管制成的逻辑元件 为载体的电路
模拟信号是指随时间连续变化的信号，但现实中是无法存储无限的模拟信号，所以根据奎斯特原理对模拟信号取样后得到离散信号，这样取样能保证信息不丢失，取样得到的离散信号数值使用数字表示，得到数字信号，这样对模拟量的计算就会转化为对数字量的计算，在计算时为了尽可能的简化，采用了二进制表示，它的基数只有01，易于用晶体管制成的逻辑元件实现。
二进制数在计算时会对应真实世界的符号位，为了将符号位也引进计算，提出了原码/反码/补码等各种二进制的不同表示形式，真实模拟量被二进制数字化表示后，要想弄清楚它们之间的关系，需要对其进行计算，真实的计算包括逻辑计算和算术计算，由计算机中的cpu部件进行实现，计算过程中可能会产生各种中间量和最终结果，这些数据由计算机中的存储器进行实现。
在逻辑代数的应用中如何找到最简计算方法，就要明白功能-函数/函数-功能的转化,在设计对应的复杂器件时，通常经过以下步骤：
 1.明确输入输出关系 2.画出真值表 3.得到真值表的逻辑函数 4.化简逻辑函数  5.基本门电路 计算机除了包含cpu，存储器，还有大量的输入输出设备，这种体系即为冯诺伊曼体系
利用晶体管可以搭建出复杂的部件，这些部件可以完成逻辑与算数运算，数据存储等功能
常见的简单门电路有：与门，或门，非门，与非门，或非门，同或门，异或门
异或门搭建：
6.基本部件 进行逻辑运算时需要涉及到加减乘除，对应的器件设计如下：
6.1 多位并行加减法器 全加器：输入是2个一位加数和1个一位进位，输出是1个一位结果和1个一位进位
一个全加器计算的只是2个一位数，要想同时进行多个一位数的计算，就需要将其串联起来，得到串行四位补码全加器
串行多位补码全加器只能计算加法，可以通过改造加入p输入控制第二位的正负，得到串行四位补码加减法器
串行四位补码加减法器在计算时会产生溢出，需要对溢出做处理
串行四位补码加减法器在计算时下一位的计算需要上一步算好的进位，速度较慢，所以需要将串行打破，改造成并行，得到并行四位补码加减法器
并行四位补码加减法器要想再次扩充，同样需要按照上面的步骤将串行链改造为并行链，抽象出并行部件6.2 多位并行乘除法器 在进行乘法运算时，实际可以转化成加法运算，2位数相乘时的中间量进行累加，每次累加结果右移一位，将右移部分移到乘数寄存器当中
6.3 存储器 </description>
    </item>
    
    <item>
      <title>4.mac终端配置</title>
      <link>https://Apollo2light.github.io/Apollo2light/tools/4.mac%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 29 Apr 2022 02:33:28 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/tools/4.mac%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE/</guid>
      <description>1.终端 0.iTerm2是默认终端的替代品，oh-my-zsh是为了简化zsh的配置的shell
1.查看所有shell
cat /etc/shells 2.默认shell
新版zsh默认zsh：echo $SHELL 更换默认shell：chsh -s /bin/zsh 3.配置文件
#所有命令失效： export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin - a. /etc/profile - b. /etc/paths - c. ~/.bash_profile - d. ~/.bash_login - e. ~/.profile - f. ~/.bashrc(启动终端自动加载) 2.配置环境变量 Mac的usr/bin目录是不允许增删文件的，可以通过向usr/local/bin增删文件来实现在终端里直接运行
#移动软件 sudo mv -f 文件名 /usr/local #添加变量 sudo vim /etc/profile # maven环境变 MAVEN_HOME=&amp;#34;/usr/local/apache-maven-3.8.4&amp;#34; export MAVEN_HOME export PATH=${PATH}:${MAVEN_HOME}/bin source /etc/profile 3.快捷键 1.截图：Command + Shift + 4 2.录屏：Command + Shift + 5 4.常用命令 改主机名: hostnamectl set-hostname npm换源: npm config set registry https://registry.</description>
    </item>
    
    <item>
      <title>3.git博客</title>
      <link>https://Apollo2light.github.io/Apollo2light/tools/3.git%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Fri, 29 Apr 2022 02:30:57 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/tools/3.git%E5%8D%9A%E5%AE%A2/</guid>
      <description>0.技术  hugo：生成站点 github pages：静态托管 picgo：存图  1.步骤  1.申请GitHub账号并配置ssh 2.brew安装hugo后选择主题 3.熟悉常见hugo指令 4.GitHub pages部署博客  2.指令 #安装hugo brew install hugo #新建站点 hugo new site xx #添加主题 cd xx git clone https://github.com/rmsubekti/the-roots-home.git themes/the-roots-home hugo server -t the-roots-home --buildDrafts #打包 hugo --theme=the-roots-home --baseUrl=&amp;#34;https://Apollo2light.github.io&amp;#34; --buildDrafts 3.写博客 #新建页面 cd apo_blog hugo new xx/xx.md #编写内容 code #打包 hugo --theme=the-roots-home --baseUrl=&amp;#34;https://Apollo2light.github.io/Apollo2light/&amp;#34; --buildDrafts #将打包好的public内容复制到apollo_blog #上传到apollo仓库 git add . git config --local user.name &amp;#39;Apollo2light&amp;#39; git config --local user.email &amp;#39;2141975795@qq.</description>
    </item>
    
    <item>
      <title>2.git多账号</title>
      <link>https://Apollo2light.github.io/Apollo2light/tools/2.git%E5%A4%9A%E8%B4%A6%E5%8F%B7/</link>
      <pubDate>Fri, 29 Apr 2022 02:30:38 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/tools/2.git%E5%A4%9A%E8%B4%A6%E5%8F%B7/</guid>
      <description>0.使用 使用的都是ssh协议
git clone git@Apollo2light.github.com:Apollo2light/Apollo2light.git 1.单客户端多账号 1.1 问题描述 单个客户端如何管理 多个账号在多个代码托管平台的代码拉取推送？
 a用户  github.come gitee.com   b用户  github.com gitee.com    1.2 解决方案  1.本地生成多个账号对应不同平台的ssh公私钥 2.将公钥部署到对应平台 3.本地拉取推送  1.2.1 生成公私钥 #进入公私钥配置地址 cd ~/.ssh/ #生成公私钥,ed25519为生成时使用的算法 ssh-keygen -t ed25519 -C &amp;#34;a@qq.com&amp;#34; ssh-keygen -t ed25519 -C &amp;#34;b@qq.com&amp;#34; #添加到ssh-agent，加快速度 eval &amp;#34;$(ssh-agent -s)&amp;#34; ssh-add -K ~/.ssh/id_a_ed25519 ssh-add -K ~/.ssh/id_b_ed25519 #配置访问时不同用户对应的私钥 vim config #======================== #github gaoyakang Host gaoyakang.github.com HostName github.com IdentityFile ~/.ssh/id_306_ed25519 user git #github apollo Host Apollo2light.</description>
    </item>
    
    <item>
      <title>1.git学习</title>
      <link>https://Apollo2light.github.io/Apollo2light/tools/1.git%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Fri, 29 Apr 2022 02:29:45 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/tools/1.git%E5%AD%A6%E4%B9%A0/</guid>
      <description>0.必知 学习git就3点：分区，分支与远程。
1.分布式版本控制系统 1.1 本质 git是分布式版本控制系统，它与集中式版本控制的本质区别是：
 分布式：客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录 集中式：客户端只提取最新版本的文件快照，不包括完整的历史记录  1.2 配置  /etc/gitconfig 文件：系统级别，git config –system对当前操作系统所有用户生效 ~/.gitconfig 文件：用户级别，git config –global 对当前操作系统该用户生效 .git/config 文件：当前文件级别，git config –local仅针对当前项目有效  git config —list #配置列表 git config --global user.name #用户名 git config --global user.email #用户邮箱 1.3 分区 对于任何一个文件，在 Git 内都只有三种状态：
 已提交（committed）：该文件已经被安全地保存在本地数据库中了 已修改（modified）：修改了某个文件 已暂存（staged）：已修改的文件放在下次提交时要保存的清单中  因此可以看到 Git 管理项目时，文件流转的三个区域：
 工作目录：编辑代码 暂存区域：完成编辑但未提交 本地仓库：.git目录，存放数据和修改信息  HEAD：指向当前所处分支 description：仅供 GitWeb 程序使用，无需关心 info/：全局性排除文件 config：配置文件 hooks/：客户端或服务端的钩子脚本 index：暂存区信息 objects/：所有存储的数据 refs/：存储指向数据（分支、远程仓库和标签等)的提交对象的指针    2.</description>
    </item>
    
    <item>
      <title>10.nodejs基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/10.nodejs%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 23:04:13 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/10.nodejs%E5%9F%BA%E7%A1%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>9.webpack基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/9.webpack%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 23:00:35 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/9.webpack%E5%9F%BA%E7%A1%80/</guid>
      <description>(一) webpack安装使用 1.简介  webpack是个打包工具，它默认处理js文件，同时也能借助loaders实现对其他类型文件的处理，同时还能用插件来简化我们的开发流程。
 2.配置环境 先要安装一下准备环境，node，因为webpcak是基于node的打包工具 其次要安装webpack和webpack-cli
npm init -y npm install webpack webpack-cli -D 3.命令行打包 安装好了以后，我们可以通过命令行直接来进行打包，可以先新建一个index.js文件，然后在命令行:
npx webpack index.js 打包完成后会有一个默认的打包文件，我们要想看看效果可以新建一个index.html来引入默认的打包文件，然后看效果。
4.脚本打包 在此之前，我们先来修改一下目录，让结构更加清晰，我们新建一个src目录，将index.js放在里面，然后新建一个dist目录，将index.html放在里面
4.1 配置webpack.config.js 接着在根目录下新建一个webpack.config.js的文件，然后在里面配置一些打包的参数，
const path = require(&amp;#39;path&amp;#39;); module.exports = { entry:{ &amp;#39;main&amp;#39;:&amp;#39;./src/index.js&amp;#39; }, output:{ filename:&amp;#39;bundle.js&amp;#39;, path:path.resolve(__dirname,&amp;#39;dist&amp;#39;) } } 4.2 配置package.json 配置好了以后，我们再来配置一下package.json文件，实现脚本打包的功能，
{ &amp;#34;scripts&amp;#34;: { &amp;#34;bundle&amp;#34;: &amp;#34;webpack&amp;#34; }, } 此时在命令行中直接使用 npm run bundle，等待打包成功后，手动打开我们的index.html文件看看效果，至此我们已经完成了webpack的安装和使用。
（二）webpack打包资源(loader)  前面我们安装并使用了webpack，我们处理的内容是js文件，那它如何处理其他类型的文件呢？比如说图片，css，字体等等，这就需要用到loaders，也就是说，webpack能认得js文件，但他不认识其他文件，所以需要一个中间人来告诉他该怎么处理. ###1.处理图片资源 首先先来看一下图片文件。首先我们先来截屏一张图片，然后把它放在src/dog.png，然后要把它挂载在index.html上，在index.js中这样来写；
 import dog from &amp;#39;./dog.png&amp;#39;; var img = new Image(); img.</description>
    </item>
    
    <item>
      <title>8.ts基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/8.ts%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 23:00:24 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/8.ts%E5%9F%BA%E7%A1%80/</guid>
      <description></description>
    </item>
    
    <item>
      <title>7</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/7.%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 23:00:10 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/7.%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</guid>
      <description>1.简介 1.每个用户针对每个公众号会产生一个安全的OpenID 2.一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID 3.在申请到认证公众号之前，申请一个接口测试号，立即开始接口测试开发 4.每个接口都有每日接口调用频次限制 5.公众平台以access_token为接口调用凭据，它在2小时内有效，1天内获取次数有限 6.公众平台接口调用仅支持80端口 7.公众号主要通过公众号消息会话 公众号内网页来为用户提供服务 8.公众号消息会话：公众号是以微信用户的一个联系人形式存在的，消息会话是公众号与用户交互的基础 9.消息服务的类型：群发消息，被动回复消息(加解密)，客服消息，模板消息 10.公众号内网页：获取用户的基本信息，微信JS-SDK EncodingAESKey: ZroCcwPJ2wVUemo94iPc8DJHiEXi3lHcJ3aXKDwUI2r 2.步骤 1.申请自己服务器，搭建web服务，申请公众号，在微信公众号平台的设置与开发-基本配置添加url(开发者ip)，token(验证开发者)和EncodingAESKey(消息加密密钥) 2.在微信公众号平台填好开发者信息后点击提交，微信服务器会向开发者服务器发送signature，timestamp，nonce，开发者用token, timestamp, nonce组合加密生成hashcode，对比微信发来的signature和自己生成的hashcode是否一致，如果一致返回echostr到微信服务器 3.用户发送消息到公众号，微信服务器将消息包装成xml格式发往开发者服务器，开发者服务器解析后发回内容到微信服务器，微信服务器解析后发给用户 微信文档：https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Getting_Started_Guide.html
centos防火墙：https://blog.csdn.net/s_p_j/article/details/80979450 https://blog.csdn.net/Linda_Lindaaaa/article/details/88836146</description>
    </item>
    
    <item>
      <title>4.jquery基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/4.jquery%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:58:40 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/4.jquery%E5%9F%BA%E7%A1%80/</guid>
      <description>1.匿名函数自执行 jquery2.0.3中，源码首先是一个自执行的匿名函数, 匿名函数就是没有函数名的函数，目的是为了保护变量不被污染,如下：
(function(window,undefined){ //具体源码  })(window); 要理解它需要先来了解js的函数命名：
js函数有2种命名方式：声明式和函数表达式
 声明式：function demo(){ //会被解释器优先编译 } 函数表达式： let demo = function(){ //解释器逐行解释 }  声明式：不论在哪里调用demo都能正常输出a，因为在开始执行前声明的函数都被提升了
demo(); function demo(){ console.log(&amp;#39;a&amp;#39;) } 函数表达式：必须要在表达式后才能调用demo，因为解释器是逐行执行
demo(); let demo = function(){ console.log(&amp;#39;a&amp;#39;) } 比对一下就可知：
(function(){ }) () | | demo () 那为什么不写成：function(){ }()呢？答案是语法里并不支持这么做，最简的方式就是加小括号
(function(){ })() 2.封装好的功能暴露到全局 采用匿名函数自执行可以很好的保护变量不受污染，但也需要把写好的功能暴露出去提供使用,我们平常使用时：
$()或者jQuery() 在jquery2.0.3中，它是将其挂载到了window全局对象来实现的
(function(window,undefined){ if ( typeof window === &amp;#34;object&amp;#34; &amp;amp;&amp;amp; typeof window.document === &amp;#34;object&amp;#34; ) { window.jQuery = window.$ = jQuery; } })(window); 3.</description>
    </item>
    
    <item>
      <title>6.react基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/6.react%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:58:13 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/6.react%E5%9F%BA%E7%A1%80/</guid>
      <description>1.概念  单页面应用：加载单个HTML页面和所需资源，与页面的任何交互，页面都不会重新加载 jsx：js的扩展集，每个 JSX 元素只是调用 React.createElement的语法糖 组件：分为函数组件和类组件，区别是类组件上添加了许多别的特性 钩子函数：生命周期函数，在特定时间自动触发的函数 Props：jsx传值与子组件的节点组成的对象，props 是只读的 State：组件内部的数据，只能通过setState({ })更改 react非受控组件：用非react处理数据方式处理的组件 状态提升：不同层级子组件传值 组合继承：组件通过组合堆砌而不是继承实现,实质相当于槽的概念 context：复杂组件传值 错误边界：避免出错导致应用崩溃 Ref转发：组件外选中特定的dom refdom：组件内选中特定的dom 高阶组件：传入组件输出组件，实现对组件的加强，比如redux的connect Portals：组件可以脱离父组件层级挂载在DOM树的任何位置 Profiler：任意位置的性能测试 协调： diff算法 webcomponent：w3c支持的组件化标准  2.react细节 1.组件 // 1.获取容器 const domContainer = document.getElementById(&amp;#39;root&amp;#39;); // 2.创建虚拟dom //类组件 class Hello extends React.Component { constructor(props){ super(props); this.state = {name: &amp;#39;hello,world!&amp;#39;}; } componentWillMount(){ // 不能直接修改state  // this.state = { name:&amp;#39;hello&amp;#39;};  // this.setState({ name:&amp;#39;你好&amp;#39;})  } render() { return (&amp;lt;div&amp;gt;{this.state.name}&amp;lt;/div&amp;gt;) } }; //函数组件 function World(props){ console.</description>
    </item>
    
    <item>
      <title>5.vue基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/5.vue%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:57:27 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/5.vue%E5%9F%BA%E7%A1%80/</guid>
      <description>0.数据监测和代理 //数据代理：通过vm操作_data中的属性 //vue内部: vm._data = data Object.defineProperty(vm,&amp;#39;a&amp;#39;,{ get(){ return vm._data.a } }) let vm = new Vue({ //等价于vm.$mount(&amp;#39;#root&amp;#39;)  el:&amp;#39;#root&amp;#39;, //函数式必须返回对象  data(){ return{ a:1 } } }) let data = { name:&amp;#39;a&amp;#39;, address:&amp;#39;b&amp;#39; } const obs = new Observer(data); console.log(obs); let vm = {} vm._data = data = obs; function Observer(obj){ const keys = Object.keys(obj); keys.forEach((k) =&amp;gt; { Object.defineProperty(this,k,{ get(){ return obj[k]; }, set(val){ console.log(`${k}被改了,需要解析模版，生成虚拟dom，渲染页面`) obj[k] = val; } }) }) } 添加响应式对象：vm.</description>
    </item>
    
    <item>
      <title>3.js基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/3.js%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:48:33 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/3.js%E5%9F%BA%E7%A1%80/</guid>
      <description>0.前提 javascript包括三部分：
 1.ECMA：基础语法 2.DOM: 操作文档节点 3.BOM：操作浏览器节点 str方法：https://www.runoob.com/js/js-obj-string.html arr方法：https://www.runoob.com/jsref/jsref-obj-array.html reg方法：https://www.runoob.com/jsref/jsref-obj-regexp.html  1.变量  值：复制新内存 引用：指向同一块内存的地址  let obj0 = { name:&amp;#34;deepcopy&amp;#34;, description:&amp;#34;copy all args from object except its own prop&amp;#34;, arr:[&amp;#34;refrence&amp;#34;,&amp;#34;data&amp;#34;] } let obj1 = { name:&amp;#34;deepcopy&amp;#34;, description:&amp;#34;copy all args from object except its own prop&amp;#34;, arr:[&amp;#34;refrence&amp;#34;,&amp;#34;data&amp;#34;], obje: obj0 } /** * 深拷贝 */ function deepCopy(obj){ //边界判断  if(typeof obj !=&amp;#34;object&amp;#34; || obj == null){ return obj; } //定义返回结果  let result; if(obj instanceof Array){ //待拷贝的对象是数组类型  result = [] }else{ //待拷贝的对象是object类型  result = {} } //开始拷贝  for (const key in obj) { //只拷贝obj自身的属性  if (obj.</description>
    </item>
    
    <item>
      <title>2.css基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/2.css%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:48:26 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/2.css%E5%9F%BA%E7%A1%80/</guid>
      <description>css资料  css属性：https://www.runoob.com/cssref/css-reference.html css选择器：https://www.runoob.com/cssref/css-selectors.html css动画：https://www.runoob.com/cssref/css-selectors.html css单位：https://www.runoob.com/cssref/css-units.html  flex布局：容器和子项目设置属性 /* 容器： */ display：flex； flex-direction：row/column/row-reverse justify-content：flex-*/center/space-* align-items：center flex-wrap：wrap align-content：center flex-flow：column wrap； /* 子项目： */ flex：1； align-self：flex-end order：-1 </description>
    </item>
    
    <item>
      <title>1.html基础</title>
      <link>https://Apollo2light.github.io/Apollo2light/frontend/1.html%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Apr 2022 22:48:19 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/frontend/1.html%E5%9F%BA%E7%A1%80/</guid>
      <description>html资料  html标签：https://www.runoob.com/tags/ref-byfunc.html html5新标签：https://www.runoob.com/html/html5-new-element.html html属性：https://www.runoob.com/tags/ref-standardattributes.html html事件：https://www.runoob.com/tags/ref-eventattributes.html 音视频：https://www.runoob.com/tags/ref-av-dom.html canvas属性：https://www.runoob.com/tags/ref-canvas.html http状态码：https://www.runoob.com/tags/html-httpmessages.html  </description>
    </item>
    
    <item>
      <title>13.springboot教程</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/13.springboot%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 10 Mar 2022 00:50:47 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/13.springboot%E5%9F%BA%E7%A1%80/</guid>
      <description>== springboot原理 == | == springboot原理 == | == springboot原理 == |
1.springboot将spring中各种繁琐的配置进行简化
以前写的ssm项目属于单体结构，springboot写的项目是微服务项目
  @springbootApplication扫描spring.factories的全部自动配置
  @condition并不会使它们全部生效，需要添加对应starter来启动
  @xxxautoConfiguration/xxProperties扫描时会存在与yml配置文件绑定实现手动改配置
  @Configuration在config/xxConfig.java自定义starter
  == 配置文件 == | == 配置文件 == | == 配置文件 == | == 配置文件 == |
1.springboot可以通过yml文件进行手动配置,常见的如下
# 端口配置 server: port: 8081 # 多环境配置 spring: profiles: active: dev --- server: port: 8082 spring: profiles: active: test 2.springboot可以通过yml文件为实体类赋值
package wiki.mrx.pojo; import lombok.AllArgsConstructor; import lombok.</description>
    </item>
    
    <item>
      <title>12.ssm整合</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/12.ssm%E6%95%B4%E5%90%88/</link>
      <pubDate>Mon, 28 Feb 2022 17:22:55 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/12.ssm%E6%95%B4%E5%90%88/</guid>
      <description>== 建数据库 == ｜ == 建数据库 == ｜ == 建数据库 == ｜
CREATE DATABASE `ssmbuild`; USE `ssmbuild`; DROP TABLE IF EXISTS `books`; CREATE TABLE `books` ( `bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT &amp;#39;书id&amp;#39;, `bookName` VARCHAR(100) NOT NULL COMMENT &amp;#39;书名&amp;#39;, `bookCounts` INT(11) NOT NULL COMMENT &amp;#39;数量&amp;#39;, `detail` VARCHAR(200) NOT NULL COMMENT &amp;#39;描述&amp;#39;, KEY `bookID` (`bookID`) )ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `BOOKS`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES (1,&amp;#39;java&amp;#39;,1,&amp;#39; 从入门到精通&amp;#39;), (2,&amp;#39;mysql&amp;#39;,10,&amp;#39;从删库到跑路&amp;#39;), (3,&amp;#39;linux&amp;#39;,5,&amp;#39;从入门到入狱&amp;#39;); == 整合mybatis == | == 整合mybatis == | == 整合mybatis == |</description>
    </item>
    
    <item>
      <title>11.spring-mvc</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/11.spring-mvc/</link>
      <pubDate>Sat, 26 Feb 2022 02:06:12 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/11.spring-mvc/</guid>
      <description>== 原始api == | == 原始api == |== 原始api == |
第一步：导包
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springmvc-study&amp;lt;/artifactId&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;springmvc-01&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;springmvc-02&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.16&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet.jsp.jstl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/project&amp;gt; 第二步：编写servlet和jsp
package wiki.mrx.controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { //模型与视图  ModelAndView mv = new ModelAndView(); mv.</description>
    </item>
    
    <item>
      <title>10.spring</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/10.spring/</link>
      <pubDate>Thu, 17 Feb 2022 01:53:32 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/10.spring/</guid>
      <description>===spring简介===｜===spring简介===｜===spring简介===
https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/spring-framework-reference/
  spring是容器，支持IOC(控制反转)和AOP(面向切面编程)
  控制反转：对象的创建和依赖关系被解耦交给第三方控制(程序由spring容器创建管理装配)而非程序本身控制(程序由程序员创建管理装配)
  依赖注入(DI):它是实现IOC的方式，所有bean对象的创建都依赖容器，其属性注入赋值也都由容器实现，具体有构造器注入(constructor-arg)，set注入(基本/引用)和第三方注入(p/c) 等形式
  spring使用｜spring使用｜spring使用｜spring使用
1.引入spring包
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-study&amp;lt;/artifactId&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;spring-01&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.15&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/project&amp;gt; 2.编写pojo实体类
package wiki.mrx.pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return &amp;#34;Hello{&amp;#34; + &amp;#34;str=&amp;#39;&amp;#34; + str + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } } 3.</description>
    </item>
    
    <item>
      <title>mybatis</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/9.mybatis/</link>
      <pubDate>Wed, 16 Feb 2022 19:58:49 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/9.mybatis/</guid>
      <description>mybatis简介|mybatis简介|mybatis简介|mybatis简介|mybatis简介|
mybatis是持久层框架，免除了 JDBC 代码以及设置参数和获取结果集的工作，通过XML 或注解来映射为数据库中的记录，MyBatis有个 Resources的工具类帮助获取配置文件内容，获取顺序为：
 1.mybatis-config.xml中的configuration &amp;mdash;&amp;ndash;&amp;gt; 配置文件 2.SqlSessionFactoryBuilder &amp;mdash;&amp;ndash;&amp;gt; 读取配置的类 3.SqlSessionFactory&amp;mdash;&amp;ndash;&amp;gt; 创建SqlSession的工厂类 4.SqlSession&amp;mdash;&amp;ndash;&amp;gt; 包含了执行sql的所有方法  ===增删改查===| ===增删改查===| ===增删改查===| ===增删改查===|
CREATE DATABASE `mybatis`; USE `mybatis`; CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL )ENGINE = INNODB DEFAULT CHARSET=utf8; INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,&amp;#34;sss&amp;#34;,&amp;#34;111111&amp;#34;), (2,&amp;#34;qq&amp;#34;,&amp;#34;134111&amp;#34;), (3,&amp;#34;rrrr&amp;#34;,&amp;#34;11111441&amp;#34;), (4,&amp;#34;ddd&amp;#34;,&amp;#34;11321111&amp;#34;); SELECT * from `user`; 新建无模版的maven项目，删除src将其作为主工程，导入jar包
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.</description>
    </item>
    
    <item>
      <title>8.javaweb</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/8.javaweb/</link>
      <pubDate>Fri, 21 Jan 2022 01:17:00 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/8.javaweb/</guid>
      <description>1.下载完全版idea 1.1 下载软件 idea软件：
链接: https://pan.baidu.com/s/1OH0ybMuGvhkXie5EJ10uEg 密码: vjli
破解包：
链接: https://pan.baidu.com/s/1cR7eZSyx7dKz3R_Ei29_mg 密码: mj88
1.2 使用方法 1.安装运行 idea，在弹出的注册界面，选择 Evaluate for free，点击 Evaluate 试用软件
2.破解文件夹中的 jetbrains-agent.jar 文件拖动到软件内，然后点击 Restart 重启软件
3.重启后，弹出激活方式，选择 Activation code，复制破解文件 Activation code，激活重启
4.重启软件，在 Get Help 中点击 About
2.新建maven项目 2.1 有模版 2.2 无模版 3.tomcat服务器 3.1环境变量 3.2 idea中配置 4.servlet项目 4.1 步骤   1.新建无模版maven项目
  2.删除src目录，在pom.xml引入javax.servlet和javax.servlet.jsp依赖
  &amp;lt;dependencies&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.0.1&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.</description>
    </item>
    
    <item>
      <title>7.数据库</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/7.%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Thu, 10 Jun 2021 20:03:59 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/7.%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>==数据库分类==|====数据库分类==|====数据库分类==|====数据库分类==|
 关系数据库：oracle，mysql 非关系数据库：mongodb，redis  基本概念|基本概念|基本概念|基本概念|基本概念|基本概念|基本概念|
 1.DQL数据查询语句，DDL数据定义语言，DCL数据控制语言，TCL事务控制语言。 2.主键：可查询到唯一对应的数据，是非空且唯一的,如果是整数类型则需要自增。 3.非外键约束：对单表字段的限定条件 4.外键约束：多表间有联系的字段添加限制条件,student表某字段可以是class表外键 5.级联操作：操作主表时影响从表的外键信息 6.事务：多条sql命令完成一件事，具有原子性，一致性，隔离性，持久性 7.脏读：一个事务读取了另一个没提交的事务 8.幻读：同一事务中，读取了其他插入的数据，导致前后结果不一致  ===常用sql命令=== | ===常用sql命令=== | ===常用sql命令=== |===常用sql命令=== |
数据库：登陆，查看，增删改查，事务； //1.登陆数据库 mysql -h localhost -u root -p //2.查看信息 show databases;//显示所有数据库 use 数据库名字;//进入该数据库 show tables;//显示该数据库下的锁哟表 desc t_student;//列出该表的所有字段 select * from t_student;//列出该表的所有数据 show create table t_student;//显示创建该字段的sql语句 exit;或者\q;//退出数据库 //3.操作数据 ## 创建表格 create table t_student( sno int(6) primary key auto_increment, sname varchar(5) not null, sex char(1) default &amp;#39;男&amp;#39; check(sex=&amp;#39;男&amp;#39;|| sex=&amp;#39;女&amp;#39;), sage int(3) check(sage&amp;gt;=18 and sage&amp;lt;=50), enterdate date, classname varchar(10), email varchar(15) unique ); ## 插入数据 insert into t_student values(); alter table t_student add score double(5,2) first/after; alter table t_student drop score; ## 修改数据 update t_student set sex = &amp;#39;女&amp;#39; where sno = 1; ## 删除数据 delete from t_student where sno=1; drop table t_student; ## 外键 ## 班级表 create table t_class( cno int(6) primary key auto_increment, cname varchar(10) not null, room char(4) ); insert into t_class values(null,&amp;#39;java001&amp;#39;,&amp;#39;r803&amp;#39;); insert into t_class values(null,&amp;#39;java002&amp;#39;,&amp;#39;r416&amp;#39;); insert into t_class values(null,&amp;#39;java002&amp;#39;,&amp;#39;r103&amp;#39;); ## 学生表 create table t_student( sno int(6) primary key auto_increment, sname varchar(5) not null, cno int(4), constraint fk_stu_cno foreign key(cno) references t_class(cno) ); insert into t_student values(null,&amp;#39;章三&amp;#39;,1),(null,&amp;#39;里斯&amp;#39;,1),(null,&amp;#39;王武&amp;#39;,2); ## 事务 commit ===JDBC=== | ===JDBC=== | ===JDBC=== | ===JDBC=== | ===JDBC=== |</description>
    </item>
    
    <item>
      <title>6.java杂项</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/6.java%E6%9D%82%E9%A1%B9/</link>
      <pubDate>Tue, 01 Jun 2021 17:40:00 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/6.java%E6%9D%82%E9%A1%B9/</guid>
      <description>1.泛型 泛型：检测或设置引用数据类型
 在集合中加泛型可以规定存入集合的数据类型，便于后续遍历 在类中加泛型可以后期传入具体的数据类型，而不必提前规定  package wiki.mrx.www; class Testa&amp;lt;E&amp;gt; { public void test(E m){ } } public class Test { public static void main(String[] args) { Testa&amp;lt;String&amp;gt; t = new Testa&amp;lt;&amp;gt;(); t.test(&amp;#34;test&amp;#34;); } } 2.异常 异常都继承于Throwable类，具体分类如下：
 Error Exception  检查异常 运行时异常 可以使用如下结构处理异常：    try{ }catch (Exception e){ e.printStackTrace(); }finally { } 3.注解 注解Annotation：代码编译时会被读取并自动操作标记好的内容
JDK内置了3个注解：@Override重写，@Deprecated过时标记 @SuppressWarnings抑制警告
jdk5.0提供了4个源注解：Retention生命周期 Target作用目标 Documented文档 Inherited继承
4.枚举 枚举类enum：可创建的对象个数是有限的，确定的
package wiki.mrx; public class Season { private final String seasonName; private final String seasonDesc; private Season(String seasonName, String seasonDesc) { this.</description>
    </item>
    
    <item>
      <title>5。java集合容器</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/5.java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Tue, 01 Jun 2021 17:39:34 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/5.java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</guid>
      <description>1.基础知识 算法：解决问题的方法，可用时间复杂度，空间复杂度来评判效率
数据结构：组织管理数据
逻辑上表现为：线性表，图，树，堆，栈
物理上表现为：紧密顺序结构，跳转链式结构
集合用于存储引用类型数据，具体分为：
 Collection接口  List子接口  ArrayList实现类 Vector实现类 LinkedList实现类   Set子接口  HashSet实现类  LinkedHashSet实现类   TreeSet实现类     Map接口  HashMap TreeMap    2.Collection接口 package wiki.mrx.www; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class TestCollection { public static void main(String[] args) { //创建对象  Collection col = new ArrayList(); //增  col.add(18); col.add(18); col.add(18); col.add(18); //增强型for循环遍历  for (Object o: col) { System.</description>
    </item>
    
    <item>
      <title>4.java网络编程</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/4.java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Tue, 01 Jun 2021 17:37:49 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/4.java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>1.基础知识 网络互联需要ip和端口，传输时需要遵守一定的规则，这个规则就是网络传输协议，即四层传输协议：
 应用层http 传输层udp,tcp 网络层ip 链路层  2.tcp协议 三次握手：客户端与服务器建立连接
四次挥手：客户端与服务器断开连接
//客户端 package wiki.mrx.www; import java.io.*; import java.net.Socket; import java.util.Scanner; public class TestClient { public static void main(String[] args){ System.out.println(&amp;#34;客户端启动了&amp;#34;); //1.创建套接字，指定ip和端口  Socket s = null; OutputStream os = null; ObjectOutputStream oos = null; InputStream is = null; DataInputStream dis = null; try { s = new Socket(&amp;#34;192.168.18.5&amp;#34;,8888); //录入账号密码  Scanner sc = new Scanner(System.in); System.out.println(&amp;#34;请录入账号：&amp;#34;); String name = sc.next(); System.</description>
    </item>
    
    <item>
      <title>3.javaio流</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/3.javaio%E6%B5%81/</link>
      <pubDate>Tue, 01 Jun 2021 17:37:33 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/3.javaio%E6%B5%81/</guid>
      <description>1.文件外 java将文件抽象为file类可以操作盘符上的文件
package wiki.mrx.www; import java.io.File; public class FileTest { public static void main(String[] args) { File f = new File(&amp;#34;/Users/gyk/desktop/test.txt&amp;#34;); System.out.println(f.canExecute() ); System.out.println(f.canRead()); System.out.println(f.getName()); System.out.println(f.canWrite()); System.out.println(f.exists()); System.out.println(f.getAbsoluteFile()); System.out.println(f.getAbsolutePath()); System.out.println(f.getParentFile()); System.out.println(f.getPath()); System.out.println(f.isDirectory()); System.out.println(f.isHidden()); System.out.println(f.lastModified()); System.out.println(f.length()); System.out.println(f.list()); } } 2.文件内 文件的本质是二进制的数据，可以把他们想像成水源和管道，他们都有进有出，根据传输的用途分为：
  处理文本文件的字符流
  处理非文本文件的字节流
  减少硬盘操作次数的处理流
  转换流
  数据流操作基本数据类型和string
  对象流操作引用类型数据
  ===========================================
处理文本文件的字符流
用FileReader和FileWriter完成文本文件复制,缓冲数组 ===========================================
//用FileReader和FileWriter完成文本文件复制 package wiki.mrx.www; import java.io.*; public class FileTest { public static void main(String[] args) throws IOException { //1.</description>
    </item>
    
    <item>
      <title>Java多线程</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/2.java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 01 Jun 2021 17:22:28 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/2.java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>1.多线程 多线程就是指多核CPU同时干多件事 在java中开启多线程有三种方法： 继承Thread类， 实现Runnable接口 实现Callable接口 但Thread因为是类的继承，所以有单继承的弊端， Runnable是接口实现，可以进行多继承， 使用时implements实现接口重写run方法，但无返回值， Callable是接口实现，可以进行多继承，也有返回值， 根据不同情况，合理选择使用Runnable和Callable接口 开启多线程后，由于多个线程执行顺序是由CPU自行调度， 这种不确定性会引起执行结果的不稳定性，除执行顺序外， 还可能出现多个线程同时操作同一份资源的情况，这会导 致资源不安全，所以需要线程同步，它的本质是一种等待 的机制，在JDK5之前，我们可以通过synchronized方 法或者synchronized同步块来对资源进行隐式加锁，保 证安全，在JDK5之后，我们可以通过lock锁机制来显式加 锁，保证安全，一般少量代码用synchronized，大量代码 用lock锁 👉synchronized方法： 可以通过private关键字来保证数据对象只能被方法访问， 所以只需要对这个方法提出一套机制，这套机制就是 synchronized 关键字，即synchronized方法 👉synchronized同步块： 有时并不需要对数据添加private关键字 ，而是在代码 中直接使用synchronized( Obj ){ }同步块，obj是 类似于上面的私有数据对象 👉lock锁机制： 多线程编程时同步队列会出现很多常见涉及到锁的情形， 在java中将这些多线程常见情形抽象封装成开箱即用的 工具包，叫做JUC，常见的JUC.locks，JUC.automic 等，它包含了很多接口和实现类，可以拿来即用 ===========================================
2.1创建：thread，runnable，callable
===========================================
//创建 //继承Thread类,重写run方法，新建对象后start开启线程 package wiki.mrx.www; public class TestThread extends Thread{ //主线程  public static void main(String[] args) { //创建并开启线程  TestThread t1 = new TestThread(); t1.start(); //主线程代码  for (int i=0;i&amp;lt;20;i++){ System.</description>
    </item>
    
    <item>
      <title>java面向对象</title>
      <link>https://Apollo2light.github.io/Apollo2light/backend/1.java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Tue, 01 Jun 2021 17:22:15 +0800</pubDate>
      
      <guid>https://Apollo2light.github.io/Apollo2light/backend/1.java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>先有逻辑正确的思路，剩余的是重复的实践与积累
1.面向对象 ===========================================
1.1 类是有属性，方法和构造器的模版，对象是实例
===========================================
1.2 面向对象的三大特性：
===========================================
 封装：修饰符，get,set方法 继承：extends，super，源头object 多态：同一行为，不同子类有不同表现，继承，子类重写父类方法，父类引用指向子类实例  //父类 package wiki.mrx.www; public class Person { //属性  private String name; static int age; //构造器：用于初始化数据  public Person(String name, int age) { this.name = name; this.age = age; } //get方法  public String getName() { return name; } public static int getAge() { return age; } //set方法  public void setName(String name) { this.name = name; } public static void setAge(int age) { Person.</description>
    </item>
    
  </channel>
</rss>